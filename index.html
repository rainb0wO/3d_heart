<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebARæµä½“ç²’å­äº’åŠ¨ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Microsoft YaHei', sans-serif;
            background: #000;
            cursor: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* éšè—æ‘„åƒå¤´è§†é¢‘å…ƒç´ ï¼Œä»…ç”¨äºæ‰‹åŠ¿è¯†åˆ«è®¡ç®—ï¼Œä¸å±•ç¤ºç”»é¢ */
        #video {
            display: none;
        }

        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }

        #image-viewer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 80vw;
            max-height: 80vh;
            z-index: 200;
            display: none;
            border: 3px solid white;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.5);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        #image-viewer img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        #close-btn {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 30px;
            height: 30px;
            background: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }

        #close-btn:hover {
            transform: scale(1.1);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 300;
        }

        #fps {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            z-index: 100;
        }

        #upload-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        #upload-label {
            display: inline-block;
            padding: 8px 16px;
            background: rgba(255, 107, 157, 0.8);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        #upload-label:hover {
            background: rgba(255, 107, 157, 1);
        }

        #file-input {
            display: none;
        }

        #upload-info {
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <!-- éšè—çš„è§†é¢‘å…ƒç´ ï¼Œä»…ç”¨äºæ‰‹åŠ¿è¯†åˆ« -->
    <video id="video" autoplay playsinline></video>
    <div id="status">æ­£åœ¨åˆå§‹åŒ–ç²’å­ç³»ç»Ÿå’Œæ‰‹åŠ¿è¯†åˆ«...</div>
    <div id="fps">FPS: --</div>
    <div id="upload-container">
        <label for="file-input" id="upload-label">ğŸ“¸ ä¸Šä¼ å›¾ç‰‡</label>
        <input type="file" id="file-input" accept="image/*" multiple>
        <div id="upload-info">å·²ä¸Šä¼  0 å¼ å›¾ç‰‡</div>
    </div>
    <div id="image-viewer">
        <img id="viewer-img" src="" alt="å›¾ç‰‡æŸ¥çœ‹å™¨">
        <button id="close-btn">Ã—</button>
    </div>
    <div id="loading">æ­£åœ¨åŠ è½½...</div>

    <!-- ä½¿ç”¨unpkg CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // å…¨å±€å˜é‡
        let uploadedImages = []; // å­˜å‚¨ä¸Šä¼ çš„å›¾ç‰‡å¯¹è±¡URLå’Œçº¹ç†
        let scene, camera, renderer;
        let video, hands;
        let gestureState = 'normal';
        let particleCount = 15000; // 10000+ç²’å­
        let imageTextures = [];
        let imagesLoaded = 0;
        
        // ç‰©ç†ç³»ç»Ÿ
        let particles = []; // ç²’å­æ•°æ®æ•°ç»„
        let instancedMesh = null;
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        // æ‰‹åŠ¿æ§åˆ¶å‚æ•°
        let handPosition = { x: 0, y: 0, z: 0 };
        let handVelocity = { x: 0, y: 0, z: 0 };
        let rotationSpeed = { x: 0, y: 0 };
        let gestureIntensity = 0; // æ‰‹åŠ¿å¼ºåº¦ 0-1

        // åˆå§‹åŒ–åœºæ™¯
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setAnimationLoop(animate);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // æ·»åŠ ç‚¹å…‰æº
            const pointLight = new THREE.PointLight(0xff6b9d, 1, 100);
            pointLight.position.set(0, 0, 10);
            scene.add(pointLight);
        }

        // ä»ä¸Šä¼ çš„æ–‡ä»¶åˆ›å»ºçº¹ç†
        function createTextureFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.minFilter = THREE.LinearMipmapLinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                        texture.generateMipmaps = true;
                        texture.needsUpdate = true;
                        resolve({ texture, objectURL: e.target.result, file });
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        async function handleFileUpload(files) {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('status').textContent = 'æ­£åœ¨å¤„ç†ä¸Šä¼ çš„å›¾ç‰‡...';

            try {
                const fileArray = Array.from(files);
                const promises = fileArray.map(file => createTextureFromFile(file));
                const results = await Promise.all(promises);

                // æ¸…ç†æ—§çš„çº¹ç†å’ŒURL
                uploadedImages.forEach(item => {
                    if (item.objectURL) {
                        URL.revokeObjectURL(item.objectURL);
                    }
                    if (item.texture) {
                        item.texture.dispose();
                    }
                });

                uploadedImages = results;
                imageTextures = results.map(r => r.texture);

                document.getElementById('upload-info').textContent = `å·²ä¸Šä¼  ${uploadedImages.length} å¼ å›¾ç‰‡`;
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼æ­£åœ¨åˆ›å»ºç²’å­ç³»ç»Ÿ...';

                // é‡æ–°åˆ›å»ºç²’å­ç³»ç»Ÿ
                if (instancedMesh) {
                    scene.remove(instancedMesh);
                    instancedMesh.geometry.dispose();
                    instancedMesh.material.dispose();
                    instancedMesh = null;
                }
                particles = [];
                createParticleSystem();

                document.getElementById('status').textContent = 'ç²’å­ç³»ç»Ÿå·²æ›´æ–°ï¼Œæ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª';
            } catch (error) {
                console.error('å›¾ç‰‡å¤„ç†å¤±è´¥:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').textContent = 'å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•';
            }
        }

        // åˆå§‹åŒ–å›¾ç‰‡åŠ è½½ï¼ˆä¸å†ä»æ–‡ä»¶è·¯å¾„åŠ è½½ï¼‰
        function initImages() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status').textContent = 'è¯·ä¸Šä¼ å›¾ç‰‡ä»¥åˆ›å»ºç²’å­ç³»ç»Ÿ';
            // å¦‚æœæ²¡æœ‰ä¸Šä¼ å›¾ç‰‡ï¼Œä½¿ç”¨é»˜è®¤ç²’å­
            createParticleSystem();
        }

        // åˆ›å»ºç²’å­ç³»ç»Ÿï¼ˆä½¿ç”¨BufferGeometryä¼˜åŒ–æ€§èƒ½ï¼‰
        function createParticleSystem() {
            // åˆ›å»ºç¼“å†²åŒºå‡ ä½•ä½“
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            // éšæœºé€‰æ‹©çº¹ç†
            const textures = imageTextures.length > 0 ? imageTextures : [];
            const material = textures.length > 0 
                ? new THREE.PointsMaterial({
                    map: textures[Math.floor(Math.random() * textures.length)],
                    size: 0.025,  // æ›´ç»†è…»çš„ç²’å­å¤§å°
                    transparent: true,
                    opacity: 0.7,  // ç¨å¾®é™ä½é€æ˜åº¦ï¼Œæ›´æŸ”å’Œ
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    vertexColors: false,
                    sizeAttenuation: true,
                    alphaTest: 0.001  // ä¼˜åŒ–é€æ˜æ¸²æŸ“
                })
                : new THREE.PointsMaterial({
                    color: 0xff6b9d,
                    size: 0.025,  // æ›´ç»†è…»çš„ç²’å­å¤§å°
                    transparent: true,
                    opacity: 0.7,  // ç¨å¾®é™ä½é€æ˜åº¦ï¼Œæ›´æŸ”å’Œ
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    sizeAttenuation: true,
                    alphaTest: 0.001  // ä¼˜åŒ–é€æ˜æ¸²æŸ“
                });

            // åˆå§‹åŒ–ç²’å­æ•°æ®ï¼ˆåŒ…å«ä½ç½®ã€é€Ÿåº¦ã€åŠ é€Ÿåº¦ï¼‰
            particles = [];
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 8 + 2;
                const height = (Math.random() - 0.5) * 10;

                const x = Math.cos(angle) * radius;
                const y = height;
                const z = Math.sin(angle) * radius;

                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;

                // éšæœºé¢œè‰²ï¼ˆå¦‚æœä½¿ç”¨é»˜è®¤æè´¨ï¼‰
                colors[i3] = 1; // R
                colors[i3 + 1] = 0.4 + Math.random() * 0.3; // G
                colors[i3 + 2] = 0.6 + Math.random() * 0.3; // B

                // æ›´ç»†è…»çš„ç²’å­å¤§å°ï¼Œå‡å°å˜åŒ–èŒƒå›´
                sizes[i] = 0.02 + Math.random() * 0.015;  // 0.02-0.035çš„ç»†è…»èŒƒå›´

                particles.push({
                    position: new THREE.Vector3(x, y, z),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02
                    ),
                    acceleration: new THREE.Vector3(0, 0, 0),
                    targetPosition: new THREE.Vector3(0, 0, 0),
                    damping: 0.92 + Math.random() * 0.03, // é˜»å°¼ç³»æ•° 0.92-0.95
                    maxSpeed: 0.4 + Math.random() * 0.2, // æœ€å¤§é€Ÿåº¦ 0.4-0.6
                    textureIndex: textures.length > 0 ? Math.floor(Math.random() * textures.length) : 0,
                    size: sizes[i]
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // åˆ›å»ºPointså¯¹è±¡
            instancedMesh = new THREE.Points(geometry, material);
            instancedMesh.frustumCulled = false;

            scene.add(instancedMesh);
        }

        // æ›´æ–°ç²’å­ä½ç½®ç¼“å†²åŒº
        function updateParticlePositions() {
            if (!instancedMesh || !particles) return;
            
            const positions = instancedMesh.geometry.attributes.position.array;
            
            for (let i = 0; i < particles.length; i++) {
                const i3 = i * 3;
                const particle = particles[i];
                positions[i3] = particle.position.x;
                positions[i3 + 1] = particle.position.y;
                positions[i3 + 2] = particle.position.z;
            }
            
            instancedMesh.geometry.attributes.position.needsUpdate = true;
        }

        // ç”Ÿæˆçˆ±å¿ƒå½¢çŠ¶çš„ç‚¹ï¼ˆå¢å¤§å°ºå¯¸ï¼Œå‡å°‘éšæœºæ€§ï¼Œè®©çˆ±å¿ƒæ›´æ¸…æ™°ï¼‰
        function generateHeartShape(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                // çˆ±å¿ƒå‚æ•°æ–¹ç¨‹
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                // å¢å¤§çˆ±å¿ƒå°ºå¯¸ï¼ˆä»0.12æ”¹ä¸º0.25ï¼‰ï¼Œå‡å°‘éšæœºåç§»ï¼ˆä»0.3æ”¹ä¸º0.1ï¼‰
                points.push(new THREE.Vector3(
                    x * 0.25 + (Math.random() - 0.5) * 0.1,
                    y * 0.25 + (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.5  // å‡å°‘Zè½´éšæœºèŒƒå›´
                ));
            }
            return points;
        }

        // ç”Ÿæˆæ•£å¼€ç›®æ ‡ä½ç½®ï¼ˆçƒŸèŠ±æ•ˆæœï¼‰
        function generateScatterTargets(count) {
            const targets = [];
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 5 + Math.random() * 15;
                targets.push(new THREE.Vector3(
                    radius * Math.sin(phi) * Math.cos(angle),
                    radius * Math.sin(phi) * Math.sin(angle),
                    radius * Math.cos(phi)
                ));
            }
            return targets;
        }

        // æ›´æ–°ç²’å­ç‰©ç†ç³»ç»Ÿï¼ˆé€Ÿåº¦+åŠ é€Ÿåº¦æ¨¡å‹ï¼‰
        function updateParticlePhysics(deltaTime) {
            if (!particles || particles.length === 0) return;

            let targetPositions = [];
            let attractionStrength = 0;
            let scatterTargets = [];

            // æ ¹æ®æ‰‹åŠ¿çŠ¶æ€è®¾ç½®ç›®æ ‡
            if (gestureState === 'fist') {
                // æ¡æ‹³ï¼šèšæ‹¢æˆçˆ±å¿ƒï¼ˆå¢å¼ºå¸å¼•åŠ›è®©çˆ±å¿ƒæ›´å¿«å½¢æˆï¼‰
                targetPositions = generateHeartShape(particleCount);
                attractionStrength = 0.25;  // ä»0.15å¢åŠ åˆ°0.25ï¼Œè®©ç²’å­æ›´å¿«èšæ‹¢
            } else if (gestureState === 'open') {
                // å¼ å¼€æ‰‹æŒï¼šæ•£å¼€
                scatterTargets = generateScatterTargets(particleCount);
                attractionStrength = 0.1;
            } else {
                // æ­£å¸¸çŠ¶æ€ï¼šå›´ç»•æ‰‹éƒ¨ä½ç½®
                attractionStrength = 0.05;
            }

            // æ›´æ–°æ¯ä¸ªç²’å­çš„ç‰©ç†çŠ¶æ€
            for (let i = 0; i < particles.length; i++) {
                const particle = particles[i];
                let target = null;

                // ç¡®å®šç›®æ ‡ä½ç½®
                if (gestureState === 'fist' && targetPositions[i]) {
                    target = targetPositions[i];
                } else if (gestureState === 'open' && scatterTargets[i]) {
                    target = scatterTargets[i];
                } else {
                    // æ­£å¸¸çŠ¶æ€ï¼šå›´ç»•æ‰‹éƒ¨ä½ç½®éšæœºåˆ†å¸ƒ
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 3 + Math.random() * 3;
                    target = new THREE.Vector3(
                        handPosition.x + Math.cos(angle) * radius,
                        handPosition.y + (Math.random() - 0.5) * 4,
                        handPosition.z + Math.sin(angle) * radius
                    );
                }

                if (target) {
                    particle.targetPosition.copy(target);
                }

                // è®¡ç®—æŒ‡å‘ç›®æ ‡çš„åŠ é€Ÿåº¦ï¼ˆå¼•åŠ›ï¼‰
                const direction = new THREE.Vector3()
                    .subVectors(particle.targetPosition, particle.position)
                    .multiplyScalar(attractionStrength);

                // æ·»åŠ æ‰‹éƒ¨ä½ç½®çš„å¸å¼•åŠ›ï¼ˆå¦‚æœæ‰‹éƒ¨åœ¨é™„è¿‘ï¼‰
                const handDirection = new THREE.Vector3()
                    .subVectors(handPosition, particle.position);
                const handDistance = handDirection.length();
                if (handDistance < 5) {
                    const handForce = handDirection.normalize().multiplyScalar(
                        (5 - handDistance) * 0.01 * gestureIntensity
                    );
                    direction.add(handForce);
                }

                // åº”ç”¨åŠ é€Ÿåº¦åˆ°é€Ÿåº¦ï¼ˆç‰©ç†æ¨¡å‹ï¼šF = ma, v = v0 + a*dtï¼‰
                particle.acceleration.copy(direction);
                particle.velocity.add(
                    particle.acceleration.clone().multiplyScalar(deltaTime * 60)
                );

                // é™åˆ¶æœ€å¤§é€Ÿåº¦
                const speed = particle.velocity.length();
                if (speed > particle.maxSpeed) {
                    particle.velocity.normalize().multiplyScalar(particle.maxSpeed);
                }

                // åº”ç”¨é€Ÿåº¦åˆ°ä½ç½®ï¼ˆä½¿ç”¨å›ºå®šæ—¶é—´æ­¥é•¿ç¡®ä¿ç‰©ç†ä¸€è‡´æ€§ï¼‰
                const timeStep = deltaTime * 60; // è½¬æ¢ä¸º60fpsçš„æ—¶é—´æ­¥é•¿
                particle.position.add(
                    particle.velocity.clone().multiplyScalar(timeStep)
                );

                // åº”ç”¨é˜»å°¼ï¼ˆæ¨¡æ‹Ÿç©ºæ°”é˜»åŠ›ï¼‰
                particle.velocity.multiplyScalar(particle.damping);

                // è¾¹ç•Œå¤„ç†ï¼ˆå¼¹æ€§ç¢°æ’ï¼‰
                const boundary = 20;
                const bounce = 0.7;
                if (Math.abs(particle.position.x) > boundary) {
                    particle.position.x = Math.sign(particle.position.x) * boundary;
                    particle.velocity.x *= -bounce;
                }
                if (Math.abs(particle.position.y) > boundary) {
                    particle.position.y = Math.sign(particle.position.y) * boundary;
                    particle.velocity.y *= -bounce;
                }
                if (Math.abs(particle.position.z) > boundary) {
                    particle.position.z = Math.sign(particle.position.z) * boundary;
                    particle.velocity.z *= -bounce;
                }
            }

            updateParticlePositions();
        }

        // åº”ç”¨æ—‹è½¬ï¼ˆæ—‹è½¬æ•´ä¸ªç²’å­ç³»ç»Ÿï¼‰
        function applyRotation(deltaTime) {
            if (!instancedMesh) return;

            // å¹³æ»‘æ—‹è½¬æ’å€¼
            const rotationDamping = 0.9;
            if (Math.abs(rotationSpeed.x) > 0.001 || Math.abs(rotationSpeed.y) > 0.001) {
                instancedMesh.rotation.y += rotationSpeed.y * deltaTime * 60;
                instancedMesh.rotation.x += rotationSpeed.x * deltaTime * 60;
            } else {
                // å½“æ²¡æœ‰æ‰‹åŠ¿æ—¶ï¼Œé€æ¸å‡é€Ÿ
                instancedMesh.rotation.y *= rotationDamping;
                instancedMesh.rotation.x *= rotationDamping;
            }

            // è‡ªç„¶ç¼“æ…¢æ—‹è½¬
            instancedMesh.rotation.z += 0.05 * deltaTime;
        }

        // åˆå§‹åŒ–MediaPipe Hands
        async function initMediaPipe() {
            return new Promise((resolve, reject) => {
                const mpScript = document.createElement('script');
                mpScript.src = 'https://unpkg.com/@mediapipe/hands@0.4.1675469404/hands.js';
                mpScript.onload = () => {
                    const cameraScript = document.createElement('script');
                    cameraScript.src = 'https://unpkg.com/@mediapipe/camera_utils@0.3.1675466864/camera_utils.js';
                    cameraScript.onload = resolve;
                    cameraScript.onerror = reject;
                    document.head.appendChild(cameraScript);
                };
                mpScript.onerror = reject;
                document.head.appendChild(mpScript);
            });
        }

        // è®¾ç½®æ‘„åƒå¤´å’Œæ‰‹åŠ¿è¯†åˆ«ï¼ˆéšè—ç”»é¢ï¼Œä»…ç”¨äºè¯†åˆ«ï¼‰
        async function setupCamera() {
            const statusEl = document.getElementById('status');
            video = document.getElementById('video');

            // 1. å…ˆæ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒ
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                statusEl.textContent = 'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ï¼Œè¯·åœ¨ç³»ç»Ÿæµè§ˆå™¨ï¼ˆSafari / Chromeï¼‰ä¸­æ‰“å¼€';
                return;
            }

            try {
                statusEl.textContent = 'æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™ï¼Œè¯·åœ¨å¼¹æ¡†ä¸­é€‰æ‹©å…è®¸';

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 640,
                        height: 480,
                        facingMode: 'user'
                    }
                });

                // å¦‚æœç”¨æˆ·ä¹‹å‰ç‚¹è¿‡â€œç¦æ­¢â€ï¼Œè¿™é‡Œä¼šç›´æ¥æŠ›å¼‚å¸¸ï¼Œä¸ä¼šèµ°åˆ°ä¸‹é¢
                video.srcObject = stream;
                video.onloadedmetadata = async () => {
                    statusEl.textContent = 'æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...';
                    
                    try {
                        hands = new Hands({
                            locateFile: (file) => {
                                return `https://unpkg.com/@mediapipe/hands@0.4.1675469404/${file}`;
                            }
                        });
                        
                        hands.setOptions({
                            maxNumHands: 1,
                            modelComplexity: 1,
                            minDetectionConfidence: 0.7,
                            minTrackingConfidence: 0.7
                        });

                        hands.onResults(onHandResults);
                        
                        const camera = new Camera(video, {
                            onFrame: async () => {
                                await hands.send({ image: video });
                            },
                            width: 640,
                            height: 480
                        });
                        camera.start();
                        
                        statusEl.textContent = 'æ‘„åƒå¤´å·²å¯åŠ¨ï¼Œæ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª';
                    } catch (error) {
                        console.error('MediaPipeåˆå§‹åŒ–å¤±è´¥:', error);
                        statusEl.textContent = 'æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥: ' + error.message;
                    }
                };
            } catch (error) {
                console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', error);

                // é’ˆå¯¹ä¸åŒé”™è¯¯ç»™å‡ºæ›´æ¸…æ™°æç¤º
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    statusEl.textContent = 'æ‘„åƒå¤´æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­ä¸ºæœ¬ç½‘ç«™å¼€å¯æ‘„åƒå¤´æƒé™ååˆ·æ–°é¡µé¢';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    statusEl.textContent = 'æœªæ‰¾åˆ°å¯ç”¨æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥è®¾å¤‡æ˜¯å¦æœ‰æ‘„åƒå¤´æˆ–æœªè¢«å…¶ä»–åº”ç”¨å ç”¨';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    statusEl.textContent = 'æ‘„åƒå¤´è¢«å…¶ä»–åº”ç”¨å ç”¨ï¼Œè¯·å…³é—­å…¶ä»–ä½¿ç”¨æ‘„åƒå¤´çš„åº”ç”¨åé‡è¯•';
                } else if (error.name === 'SecurityError') {
                    statusEl.textContent = 'å®‰å…¨ç­–ç•¥ç¦æ­¢è®¿é—®æ‘„åƒå¤´ï¼Œè¯·ç¡®è®¤ä½¿ç”¨çš„æ˜¯ HTTPS å¹¶åœ¨ç³»ç»Ÿæµè§ˆå™¨ä¸­æ‰“å¼€';
                } else {
                    statusEl.textContent = 'æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼š' + error.message;
                }
            }
        }

        // å¤„ç†MediaPipeæ‰‹åŠ¿è¯†åˆ«ç»“æœ
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                detectGestureFromLandmarks(landmarks);
                updateHandTracking(landmarks);
            } else {
                gestureState = 'normal';
                gestureIntensity = 0;
                rotationSpeed = { x: 0, y: 0 };
                handVelocity = { x: 0, y: 0, z: 0 };
                document.getElementById('status').textContent = 'æ‰‹åŠ¿ï¼šæœªæ£€æµ‹åˆ°æ‰‹';
            }
        }

        // æ›´æ–°æ‰‹éƒ¨è¿½è¸ª
        function updateHandTracking(landmarks) {
            const wrist = landmarks[0];
            const indexTip = landmarks[8];
            
            // å¹³æ»‘æ‰‹éƒ¨ä½ç½®ï¼ˆå‡å°‘æŠ–åŠ¨ï¼‰
            const newHandPos = {
                x: (wrist.x - 0.5) * 20,
                y: -(wrist.y - 0.5) * 15,
                z: (wrist.z - 0.5) * 10
            };

            // ä½¿ç”¨æ’å€¼å®ç°å¹³æ»‘ç§»åŠ¨
            handPosition.x += (newHandPos.x - handPosition.x) * 0.2;
            handPosition.y += (newHandPos.y - handPosition.y) * 0.2;
            handPosition.z += (newHandPos.z - handPosition.z) * 0.2;

            // è®¡ç®—æ‰‹éƒ¨é€Ÿåº¦ï¼ˆç”¨äºç‰©ç†åé¦ˆï¼‰
            handVelocity.x = newHandPos.x - handPosition.x;
            handVelocity.y = newHandPos.y - handPosition.y;
            handVelocity.z = newHandPos.z - handPosition.z;

            // æ›´æ–°æ—‹è½¬é€Ÿåº¦ï¼ˆåŸºäºé£ŸæŒ‡ä½ç½®ï¼‰
            const normalizedX = (indexTip.x - 0.5) * 2;
            const normalizedY = (indexTip.y - 0.5) * 2;
            
            const distanceToEdge = Math.min(
                Math.abs(1 - Math.abs(normalizedX)),
                Math.abs(1 - Math.abs(normalizedY))
            );
            
            const speedMultiplier = 1 + (1 - distanceToEdge) * 3; // 1x åˆ° 4x
            
            rotationSpeed.y = normalizedX * 0.015 * speedMultiplier;
            rotationSpeed.x = -normalizedY * 0.015 * speedMultiplier;
        }

        // æ£€æµ‹æ‰‹åŠ¿ï¼ˆMediaPipeæ ¼å¼ï¼‰
        function detectGestureFromLandmarks(landmarks) {
            const thumbTip = landmarks[4];
            const thumbIP = landmarks[3];
            const indexTip = landmarks[8];
            const indexPIP = landmarks[6];
            const middleTip = landmarks[12];
            const middlePIP = landmarks[10];
            const ringTip = landmarks[16];
            const ringPIP = landmarks[14];
            const pinkyTip = landmarks[20];
            const pinkyPIP = landmarks[18];
            const wrist = landmarks[0];

            // è®¡ç®—æ‰‹æŒ‡æ˜¯å¦ä¼¸å‡º
            const thumbExtended = thumbTip.y < thumbIP.y;
            const indexExtended = indexTip.y < indexPIP.y;
            const middleExtended = middleTip.y < middlePIP.y;
            const ringExtended = ringTip.y < ringPIP.y;
            const pinkyExtended = pinkyTip.y < pinkyPIP.y;

            const extendedFingers = [thumbExtended, indexExtended, middleExtended, ringExtended, pinkyExtended].filter(Boolean).length;

            // æ£€æµ‹æŒ‡å‘
            const pointing = indexExtended && !middleExtended && !ringExtended && !pinkyExtended;
            const pointingForward = pointing && indexTip.z < wrist.z - 0.05;

            // æ£€æµ‹æ‰‹åŠ¿å¼ºåº¦ï¼ˆåŸºäºæ‰‹æŒ‡çš„å¼ å¼€ç¨‹åº¦ï¼‰
            const fingerSpacing = Math.sqrt(
                Math.pow(indexTip.x - middleTip.x, 2) +
                Math.pow(indexTip.y - middleTip.y, 2)
            );
            gestureIntensity = Math.min(1, fingerSpacing * 10);

            let newGestureState = gestureState;

            if (pointingForward) {
                newGestureState = 'point';
            } else if (extendedFingers === 0 || extendedFingers === 1) {
                newGestureState = 'fist';
                gestureIntensity = 1;
            } else if (extendedFingers >= 4) {
                newGestureState = 'open';
                gestureIntensity = Math.max(0.5, gestureIntensity);
            } else {
                newGestureState = 'normal';
            }

            if (newGestureState !== gestureState) {
                gestureState = newGestureState;
                if (gestureState === 'point') {
                    showRandomImage();
                }
            }

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            const statusText = {
                'fist': 'æ‰‹åŠ¿ï¼šæ¡æ‹³ - ç²’å­èšæ‹¢æˆçˆ±å¿ƒ',
                'open': 'æ‰‹åŠ¿ï¼šå¼ å¼€æ‰‹æŒ - ç²’å­æ•£å¼€',
                'point': 'æ‰‹åŠ¿ï¼šæŒ‡å‘å±å¹• - æ˜¾ç¤ºå›¾ç‰‡',
                'normal': 'æ‰‹åŠ¿ï¼šæ­£å¸¸'
            };
            document.getElementById('status').textContent = statusText[gestureState] || 'æ‰‹åŠ¿ï¼šæ­£å¸¸';
        }

        // éšæœºæ˜¾ç¤ºå›¾ç‰‡
        function showRandomImage() {
            if (uploadedImages.length === 0) return;
            const randomIndex = Math.floor(Math.random() * uploadedImages.length);
            const img = document.getElementById('viewer-img');
            const viewer = document.getElementById('image-viewer');
            
            img.src = uploadedImages[randomIndex].objectURL;
            viewer.style.display = 'block';
            
            setTimeout(() => {
                viewer.style.display = 'none';
            }, 5000);
        }

        // å…³é—­å›¾ç‰‡æŸ¥çœ‹å™¨
        document.getElementById('close-btn').addEventListener('click', () => {
            document.getElementById('image-viewer').style.display = 'none';
        });

        // åŠ¨ç”»å¾ªç¯
        function animate(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // è®¡ç®—FPS
            frameCount++;
            if (frameCount % 60 === 0) {
                fps = Math.round(1 / deltaTime);
                document.getElementById('fps').textContent = `FPS: ${fps} | ç²’å­æ•°: ${particleCount}`;
            }

            // æ›´æ–°ç‰©ç†ç³»ç»Ÿ
            updateParticlePhysics(deltaTime);
            
            // åº”ç”¨æ—‹è½¬
            applyRotation(deltaTime);

            // æ¸²æŸ“
            renderer.render(scene, camera);
        }

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶å¤„ç†
        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if (files.length > 0) {
                handleFileUpload(files);
            }
        });

        // é¡µé¢å…³é—­æ—¶æ¸…ç†èµ„æºå¹¶é‡ç½®çŠ¶æ€
        function cleanupAndReset() {
            // æ¸…ç†æ‰€æœ‰çº¹ç†ï¼ˆdata URLä¸éœ€è¦revokeï¼Œä¼šéšé¡µé¢å…³é—­è‡ªåŠ¨æ¸…ç†ï¼‰
            uploadedImages.forEach(item => {
                if (item.texture) {
                    item.texture.dispose();
                }
            });
            uploadedImages = [];
            imageTextures = [];

            // æ¸…ç†ç²’å­ç³»ç»Ÿ
            if (instancedMesh) {
                scene.remove(instancedMesh);
                instancedMesh.geometry.dispose();
                instancedMesh.material.dispose();
                instancedMesh = null;
            }
            particles = [];

            // é‡ç½®çŠ¶æ€
            gestureState = 'normal';
            handPosition = { x: 0, y: 0, z: 0 };
            handVelocity = { x: 0, y: 0, z: 0 };
            rotationSpeed = { x: 0, y: 0 };
            gestureIntensity = 0;

            // æ¸…ç†æ¸²æŸ“å™¨
            if (renderer) {
                renderer.dispose();
            }

            // åœæ­¢æ‘„åƒå¤´
            if (video && video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }
        }

        // ç›‘å¬é¡µé¢å…³é—­äº‹ä»¶
        window.addEventListener('beforeunload', cleanupAndReset);

        // ä¹Ÿç›‘å¬é¡µé¢éšè—äº‹ä»¶ï¼ˆæŸäº›ç§»åŠ¨æµè§ˆå™¨ï¼‰
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                // å¯é€‰ï¼šåœ¨é¡µé¢éšè—æ—¶ä¹Ÿæ¸…ç†ï¼ˆæ ¹æ®éœ€è¦ï¼‰
            }
        });

        // åˆå§‹åŒ–ï¼ˆå¯ç”¨æ‘„åƒå¤´ä¸æ‰‹åŠ¿è¯†åˆ«ï¼Œä½†ä¸å±•ç¤ºç”»é¢ï¼‰
        async function init() {
            initScene();
            initImages(); // ä¸å†åŠ è½½æ–‡ä»¶è·¯å¾„å›¾ç‰‡
            document.getElementById('status').textContent = 'æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...';
            await initMediaPipe();
            await setupCamera();
        }

        // å¯åŠ¨
        init();
    </script>
</body>
</html>
